from datetime import datetime, timedelta

from aiogram import F, Router
from aiogram.types import CallbackQuery
from config import TIMEZONE
from database.models import User
from database.services.group import get_group_by_id
from database.services.user import get_users_for_notify
from filters.dispatcherFilters import IsPrivate
from loguru import logger
from utils.schedule_parser import schedule_parser

router = Router(name="schedule_handler")
router.message.filter(IsPrivate)


async def next_para(time: str) -> None:
    from bot import bot
    from database import db

    logger.debug("–ù–∞—á–∞–ª–æ –æ—Ç–ø—Ä–∞–≤–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π")

    async with db.session() as session:
        async with session.begin():
            users: list[User] = await get_users_for_notify(session)

    for user in users:

        import locale

        locale.setlocale(locale.LC_ALL, "ru_RU.UTF-8")  # FIXME: –∫–æ—Å—Ç—ã–ª—å

        selected_day: datetime = datetime.now(TIMEZONE)
        current_week: str = (
            "–ó–Ω–∞–º–µ–Ω–∞—Ç–µ–ª—å" if selected_day.isocalendar().week % 2 != 0 else "–ß–∏—Å–ª–∏—Ç–µ–ª—å"
        )  # FIXME: –ö–æ—Å—Ç—ã–ª—å

        subject: str | None = await schedule_parser.getScheduleForTime(
            user.group,
            current_week,
            selected_day.strftime("%A").capitalize(),
            time,
        )
        if subject is None:
            logger.debug(
                f"–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∑–∞ 5 –º–∏–Ω—É—Ç –¥–æ –Ω–∞—á–∞–ª–∞ –ø–∞—Ä—ã - —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.telegram_id} –Ω–µ—Ç –ø–∞—Ä—ã"
            )
        await bot.send_message(user.telegram_id, subject)
        logger.debug(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user.telegram_id} –∑–∞ 5 –º–∏–Ω—É—Ç –¥–æ –Ω–∞—á–∞–ª–∞ –ø–∞—Ä—ã")
    logger.debug("–í—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã")


async def next_day() -> None:
    from bot import bot
    from database import db

    # TODO: –¢–∏–ø –¥–Ω—è

    logger.debug("–ù–∞—á–∞–ª–æ –æ—Ç–ø—Ä–∞–≤–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π")

    async with db.session() as session:
        async with session.begin():
            users: list[User] = await get_users_for_notify(session)

    for user in users:

        import locale

        locale.setlocale(locale.LC_ALL, "ru_RU.UTF-8")  # FIXME: –∫–æ—Å—Ç—ã–ª—å

        selected_day: datetime = datetime.now(TIMEZONE) + timedelta(hours=2)
        current_week: str = (
            "–ó–Ω–∞–º–µ–Ω–∞—Ç–µ–ª—å" if selected_day.isocalendar().week % 2 != 0 else "–ß–∏—Å–ª–∏—Ç–µ–ª—å"
        )  # FIXME: –∫–æ—Å—Ç—ã–ª—å

        subject = await schedule_parser.getScheduleForDay(
            user.group,
            current_week,
            selected_day.strftime("%A").capitalize(),
        )
        await bot.send_message(user.telegram_id, subject)
        logger.debug(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user.telegram_id} –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å")
    logger.debug("–í—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã")


# FIXME: —á—Ç–æ —ç—Ç–æ —Ç–∞–∫–æ–µ? üëá (–û—Ç—Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å —ç—Ç—É —Ç–µ–º—É)
@router.callback_query(F.data == "timetable_today")
@router.callback_query(F.data == "timetable_nextday")
@router.callback_query(F.data == "timetable_current_week")
@router.callback_query(F.data == "timetable_next_week")
async def timetableForDay(callback: CallbackQuery, username: str, existingUser: User | None, db) -> None:
    logger.opt(colors=True).debug(f"[<y>{username}</y>]: Called <b>timetable</b> callback")

    if existingUser is None:
        return await callback.answer("–í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã!")

    import locale

    locale.setlocale(locale.LC_ALL, "ru_RU.UTF-8")  # FIXME: –∫–æ—Å—Ç—ã–ª—å

    selected_day: datetime = datetime.now(TIMEZONE)
    current_week: str = "–ó–Ω–∞–º–µ–Ω–∞—Ç–µ–ª—å" if selected_day.isocalendar().week % 2 != 0 else "–ß–∏—Å–ª–∏—Ç–µ–ª—å"  # FIXME: –ö–æ—Å—Ç—ã–ª—å

    if callback.data == "timetable_today":
        pass
    elif callback.data == "timetable_nextday":
        selected_day += timedelta(days=1)
        current_week: str = (
            "–ó–Ω–∞–º–µ–Ω–∞—Ç–µ–ª—å" if selected_day.isocalendar().week % 2 != 0 else "–ß–∏—Å–ª–∏—Ç–µ–ª—å"
        )  # FIXME: –∫–æ—Å—Ç—ã–ª—å
    elif callback.data == "timetable_current_week":
        start_of_week = selected_day - timedelta(days=selected_day.weekday())
        end_of_week = start_of_week + timedelta(days=6)
        schedule_for_week_str = f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Ç–µ–∫—É—â—É—é –Ω–µ–¥–µ–ª—é ({current_week}) —Å {start_of_week.strftime('%d.%m.%Y')} –ø–æ {end_of_week.strftime('%d.%m.%Y')}:\n\n"
        for i in range(7):
            day = start_of_week + timedelta(days=i)
            if i == 6 and day.strftime("%A") == "–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ":
                continue
            if i != 0 and day.strftime("%A")[0].isupper():
                schedule_for_week_str += f"{day.strftime('%A')} ({current_week}):\n"
            async with db.session() as session:
                async with session.begin():
                    group = await get_group_by_id(session, existingUser.group_id)
                schedule_for_week_str += (
                    await schedule_parser.getScheduleForDay(
                        group,
                        current_week,
                        day.strftime("%A").capitalize(),
                    )
                    + "\n\n"
                )
        await callback.message.answer(text=schedule_for_week_str.strip())
        return await callback.answer("–í–∞—à–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")

    elif callback.data == "timetable_next_week":
        start_of_week = selected_day - timedelta(days=selected_day.weekday()) + timedelta(weeks=1)
        end_of_week = start_of_week + timedelta(days=6)
        next_week_type = "–ó–Ω–∞–º–µ–Ω–∞—Ç–µ–ª—å" if current_week == "–ß–∏—Å–ª–∏—Ç–µ–ª—å" else "–ß–∏—Å–ª–∏—Ç–µ–ª—å"
        schedule_for_week_str = f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é –Ω–µ–¥–µ–ª—é ({next_week_type}) —Å {start_of_week.strftime('%d.%m.%Y')} –ø–æ {end_of_week.strftime('%d.%m.%Y')}:\n\n"
        for i in range(7):
            day = start_of_week + timedelta(days=i)
            if i == 6 and day.strftime("%A") == "–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ":
                continue
            if i != 0 and day.strftime("%A")[0].isupper():
                schedule_for_week_str += f"{day.strftime('%A')} ({next_week_type}):\n"
            async with db.session() as session:
                async with session.begin():
                    group = await get_group_by_id(session, existingUser.group_id)
            schedule_for_week_str += (
                await schedule_parser.getScheduleForDay(
                    group,
                    next_week_type,
                    day.strftime("%A").capitalize(),
                )
                + "\n\n"
            )
        await callback.message.answer(text=schedule_for_week_str.strip())
        return await callback.answer("–í–∞—à–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")

    schedule_for_week_str = f"–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {selected_day.strftime('%A')} ({current_week}):\n\n"
    async with db.session() as session:
        async with session.begin():
            group = await get_group_by_id(session, existingUser.group_id)

    schedule_for_week_str += (
        await schedule_parser.getScheduleForDay(
            group,
            current_week,
            selected_day.strftime("%A").capitalize(),
        )
        + "\n\n"
    )

    await callback.message.answer(text=schedule_for_week_str.strip())
    await callback.answer("–í–∞—à–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ")
